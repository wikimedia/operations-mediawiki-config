<?php

use Wikimedia\MWConfig\MWConfigCacheGenerator;

require_once __DIR__ . '/MWWikiversions.php';
require_once __DIR__ . '/MWConfigCacheGenerator.php';
require_once __DIR__ . '/../vendor/autoload.php';
require_once __DIR__ . '/../src/defines.php';
require_once __DIR__ . '/../wmf-config/InitialiseSettings.php';

global $wmfRealm, $wmfDatacenter;
$wmfRealm = 'production';
$wmfDatacenter = 'eqiad';

$config = wmfGetVariantSettings();

$prodWikis = MWWikiversions::readDbListFile( 'all' );
$labsOnlyWikis = array_diff( MWWikiversions::readDbListFile( 'all-labs' ), $prodWikis );
$knownDBLists = [];

foreach ( $prodWikis as $wgDBname ) {
	$fullConfig = MWConfigCacheGenerator::getCachableMWConfig( $wgDBname, $config, 'production' );
	foreach ( $fullConfig['wikiTag'] ?? [] as $tag ) {
		$knownDBLists[$tag][] = $wgDBname;
	}
}

// There is only one set of dblists for all realms combined.
// This means it is important that a labs-only wiki never be included in
// production dblists like "all", "closed", "fishbowl", "echo", etc.
//
// This caveat is validated by DblistTest::testDblistAllContainsEverything().
//
$labsOnlyTags = [ 'all-labs', 'closed-labs', 'flow_only_labs', 'flow-labs' ];
foreach ( $labsOnlyWikis as $wgDBname ) {
	$fullConfig = MWConfigCacheGenerator::getCachableMWConfig( $wgDBname, $config, 'labs' );
	foreach ( $fullConfig['wikiTag'] ?? [] as $tag ) {
		// HACK: Only write the Beta Cluster-only dblists with the Labs-specific details.
		if ( in_array( $tag, $labsOnlyTags ) ) {
			$knownDBLists[$tag][] = $wgDBname;
		}
	}
}

$untracked = [
	// This naturally contains wikis we don't know about
	'deleted',
];
// Don't let any dblists linger if they are no longer backed by the YAML source
foreach ( glob( __DIR__ . '/../dblists/*.dblist' ) as $filepath ) {
	$dblist = basename( $filepath, '.dblist' );
	if ( !in_array( $dblist, $untracked ) ) {
		unlink( $filepath );
	}
}

foreach ( $knownDBLists as $DBList => $contents ) {
	writeDBList( $DBList, $contents );
}
foreach ( glob( __DIR__ . '/../dblists/*.dbexpr' ) as $filepath ) {
	writeDBList(
		basename( $filepath, '.dbexpr' ),
		MWWikiversions::evalDbListExpression( file_get_contents( $filepath ) ),
		'dbexpr'
	);
}

/**
 * @param string $listname The name of the db list to write.
 * @param string[] $listcontent The wikidbs for the dblist contents.
 * @param string $source One of "YAML" or "dbexpr"
 */
function writeDBList( $listname, $listcontent, $source = 'YAML' ) {
	$path = __DIR__ . '/../dblists/' . $listname . '.dblist';

	// Alpha-sort the contents of the list by array value for consitency
	asort( $listcontent );

	$from = ( $source === 'dbexpr' ? " from {$listname}.dbexpr" : '' );

	if ( !file_put_contents(
		$path,
		[
			// Header warning about being a generated file
			"# NOTE: This file is automatically generated{$from}."
				. " Do not edit it directly, run 'composer buildDBLists' instead.\n",
			// The contents of the list, written one per line, unique'd
			implode( "\n", array_unique( $listcontent ) ),
			// Trailing new line for consistency
			"\n"
		],
		LOCK_EX )
	) {
		print "Unable to write to $path.\n";
		exit( 1 );
	}
}
