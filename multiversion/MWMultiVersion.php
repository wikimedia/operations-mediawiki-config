<?php
require_once __DIR__ . '/defines.php';
require_once __DIR__ . '/MWMultiVersionException.php';
require_once __DIR__ . '/MWRealm.php';
require_once __DIR__ . '/MWWikiversions.php';
require_once __DIR__ . '/../src/WmfConfig.php';

use Wikimedia\MWConfig\WmfConfig;

/**
 * Detect which wiki we're on and load the appropriate MediaWiki install.
 *
 * NOTE: Avoid setting environmental or global variables here for OOP.
 *
 * == Web requests ==
 *
 * The mock entrypoint (e.g. /w/index.php) calls MWMultiVersion::getMediaWiki which:
 * - interprets the HTTP hostname (e.g. en.wikipedia.org),
 * - maps it to a wiki ID (e.g. enwiki),
 * - maps it to a MediaWiki version (e.g. MediaWiki 1.17wmf1) as installed under /srv/mediawiki/
 * - hands the request off to same entrypoint inside the real MediaWiki installation
 *   e.g. /srv/mediawiki/php-X.Y/index.php, as if it started there all along.
 *
 * This "wrapper" leaves no trace of itself and does not alter how MediaWiki behaves,
 * with the exception of the wiki ID we are on (e.g. "enwiki"), which remains
 * accessible via `$multiVersion->getDatabase()` and is used exactly once
 * later on to assign $wgDBname near the top of LocalSettings.php/CommonSettings.php.
 *
 * Control flow:
 *
 * 1. Determine the "site/lang" pair, in setSiteInfoForWiki().
 *
 *    The site/lang terms represent roughly the family/subdomain such as
 *    wikipedia/en, wikivoyage/zh, and wikimedia/nl (chapter).
 *
 *    There are also "special" sites not part of a family with subdomains, which are standalone
 *    projects. These are under wikimedia.org (such as Meta-Wiki, Wikimedia Commons, and
 *    Wikitech) or have their own domain name (like www.mediawiki.org, and www.wikidata.org).
 *
 *    The first such "special" sites started life under Wikipedia, with Meta-Wiki on
 *    meta.wikipedia.org, and later Wikisource at sources.wikipedia.org.
 *    As such, both Wikipedia and special sites share the "site" label of "wikipedia".
 *    They also share the generic database suffix of "wiki" (enwiki, metawiki, wikidatawiki)
 *    whereas wikis part of other families use their family as database suffix
 *    (e.g. zhwikivoyage, nlwikimedia).
 *
 *    The site/lang pair is only directly used for one purpose: to determine
 *    the DB name from an HTTP hostname on web requests. Once we have the dbname,
 *    these variables are lost.
 *
 *    Once MediaWiki is initialized, WmfConfig::getConfigGlobals uses WmfConfig::SUFFIXES
 *    and SiteConfiguration to reconstruct the site/lang pair from the dbname, making it
 *    reliably available in all contexts, including in the CLI where we start with only a
 *    dbname argument, as well as within web requests for cross-wiki interactions such as
 *    reading configuration from a foreign wiki from $wgConf, given only a dbname.
 *
 *    As of 2013, the site/lang pair are discouraged from use in configuration, especially
 *    public interfaces, as they poorly reflect project structure (use domain names or wiki IDs).
 *    One notable remnant is media uploads, which feature them in both the public path at
 *    upload.wikimedia.org/$site/$lang and the internal Swift container name ($site-$lang),
 *    as configured in wmf-config/InitialiseSettings.php and wmf-config/filebackend.php.
 *
 * 2. Determine the database name, in loadDBFromSite().
 *
 *    The database name is formed from the site/lang like so:
 *    - translate dashes to underscores in the subdomain prefix
 *    - map "suffix=wikipedia" to "suffix=wiki"
 *
 *    Examples:
 *    - en/wikipedia       > enwiki
 *    - meta/wikipedia     > metawiki
 *    - zh/wikivoyage      > zhwikivoyage
 *    - roa-rup/wiktionary > roa_rupwiktionary
 *
 * 3. Determine the MediaWiki install directory, in loadVersionInfo()
 *
 *    We map the wiki ID to a MediaWiki directory, as managed in wikiversions.json.
 *
 *    This MUST NOT be edited by hand, but instead via `scap deploy-promote`
 *    from a deployment server, which edits wikiversions.json and uploads a
 *    patch directly to Gerrit on behalf of TrainBranchBot.
 *
 *    For performance reasons (avoid IO file read and JSON parse on every req), we compile
 *    this to wikiversions.php which PHP reads purely from RAM via php-opcache.
 *    This is automatically generated by scap during any deployment-related command.
 *    You can generate it separately via `scap wikiversions-compile` or with
 *    the mutiversion/bin/generate-php-wikiversions.php script.
 *
 * 4. Hand off
 *
 *    Once we're back where in MWMultiVersion::getMediaWiki, we hand off control
 *    to MW_INSTALL_PATH/$entrypoint, e.g. /srv/mediawiki/php-1.17wmf1/index.php,
 *    as if that was the document root of this domain all along.
 *
 * Within each MediaWiki install, LocalSettings.php is an alias
 * to /srv/mediawiki/wmf-config/CommonSettings.php. Once MediaWiki reaches
 * the point in Setup.php where it loads LocalSettings.php, thus wmf-config will
 * execute. There, we look back at MWMultiVersion one last time, to set $wgDBname.
 */
class MWMultiVersion {

	/** @deprecated */
	public const SUFFIXES = WmfConfig::SUFFIXES;

	/** @deprecated */
	public const DB_LISTS = WmfConfig::DB_LISTS;

	/** @var MWMultiVersion */
	private static $instance;

	/** @var string */
	private $db;

	/** @var null|false|string */
	private $version;

	/**
	 * List of *.wikimedia.org subdomains that are chapter wikis
	 * @var array
	 */
	private $wikimediaSubdomains = [
		'ae',
		'am',
		'ar',
		'az',
		'bd',
		'be',
		'br',
		'ca',
		'cn',
		'co',
		'dk',
		'ec',
		'et',
		'fi',
		'ge',
		'gr',
		'hi',
		'id',
		'id-internal',
		'il',
		'mai',
		'mk',
		'mx',
		'ng',
		'nl',
		'noboard-chapters',
		'no',
		'nyc',
		'nz',
		'pa-us',
		'pl',
		'pt',
		'punjabi',
		'romd',
		'rs',
		'ru',
		'se',
		'tr',
		'ua',
		'uk',
		've',
		'wb',
	];

	/**
	 * To get an instance of this class, use the static helper methods.
	 * @see getInstanceForWiki
	 * @see getInstanceForUploadWiki
	 */
	private function __construct() {
	}

	private function __clone() {
	}

	/**
	 * @return self
	 */
	private static function createInstance() {
		if ( isset( self::$instance ) ) {
			self::error( "MWMultiVersion instance already set!\n" );
		}
		self::$instance = new self;
		return self::$instance;
	}

	/**
	 * Create an instance by HTTP host name.
	 *
	 * Use this for all web requests, except those rewritten from
	 * upload.wikimedia.org to /w/thumb.php, or the shared auth domain.
	 *
	 * @param string $serverName HTTP host name from `$_SERVER['SERVER_NAME']`.
	 * @return MWMultiVersion
	 */
	public static function initializeForWiki( $serverName ) {
		$instance = self::createInstance();
		$instance->setSiteInfoForWiki( $serverName );
		return $instance;
	}

	/**
	 * Create an instance for upload.wikimedia.org requests to /w/thumb_handler.php.
	 *
	 * For example:
	 * <https://upload.wikimedia.org/wikipedia/commons/thumb/8/84/Example.svg/240px-Example.svg.png>
	 *
	 * TODO: As of 2022, this might be obsolete. Even before Thumbor, it
	 * seems swift-rewrite.py had already been routing requests in a way
	 * that wouldn't satisfy this condition.
	 *
	 * @param string $pathInfo CGI path info, from `$_SERVER['PATH_INFO']`.
	 * @return MWMultiVersion
	 */
	public static function initializeForUploadWiki( $pathInfo ) {
		$instance = self::createInstance();
		$instance->setSiteInfoForUploadWiki( $pathInfo );
		return $instance;
	}

	/**
	 * Create an instance for auth.wikimedia.org requests.
	 *
	 * For example:
	 * <https://auth.wikimedia.org/enwiki/wiki/Special:Userlogin>
	 *
	 * @param ?string $requestUri CGI path info, from `$_SERVER['REQUEST_URI']`.
	 * @return MWMultiVersion
	 */
	public static function initializeForSharedDomain( $requestUri ) {
		$instance = self::createInstance();
		$instance->setSiteInfoForSharedDomain( $requestUri );
		return $instance;
	}

	/**
	 * Create an instance by `--wiki` CLI parameter.
	 *
	 * This is used by MWScript.php and the `mwscript` command for
	 * running maintenance scripts.
	 *
	 * @return MWMultiVersion
	 */
	public static function initializeForMaintenance() {
		$instance = self::createInstance();
		$instance->setSiteInfoForMaintenance();
		return $instance;
	}

	/**
	 * @todo remove once all scripts have been migrated
	 * not to use CommandLineInc
	 *
	 * @return MWMultiVersion
	 */
	public static function initializeForMaintenanceOld() {
		$instance = self::createInstance();
		$instance->setSiteInfoForMaintenanceOld();
		return $instance;
	}

	/**
	 * Create an instance by explicit wiki ID.
	 *
	 * @param string $dbName
	 * @return MWMultiVersion
	 */
	public static function initializeFromDBName( $dbName ) {
		$instance = self::createInstance();
		$instance->db = $dbName;
		return $instance;
	}

	/**
	 * Get the previously created singleton for the current wiki.
	 *
	 * @return MWMultiVersion|null
	 */
	public static function getInstance() {
		return self::$instance;
	}

	/**
	 * Destroy the singleton instance.
	 *
	 * Use this to let a subsequent call create a new instance.
	 *
	 * This MUST NOT be used outside command-line or test contexts,
	 * and will exit with a fatal error in that case.
	 */
	public static function destroySingleton() {
		if ( PHP_SAPI !== 'cli' ) {
			self::error( 'Must not destroy singleton instance when used ' .
				'with non-CLI interface' );
		}
		self::$instance = null;
	}

	/**
	 * Create an instance for a web request, based on $_SERVER properties.
	 * @param ?string $serverName HTTP host name from `$_SERVER['SERVER_NAME']`.
	 * @param ?string $scriptName HTTP script name from `$_SERVER['SCRIPT_NAME']`.
	 * @param ?string $pathInfo CGI path info, from `$_SERVER['PATH_INFO']`.
	 * @param ?string $requestUri CGI request URI, from `$_SERVER['REQUEST_URI']`.
	 * @return MWMultiVersion
	 */
	public static function initializeFromServerData( $serverName, $scriptName, $pathInfo, $requestUri ) {
		if ( $scriptName === '/w/thumb.php'
			&& ( $serverName === 'upload.wikimedia.org' || $serverName === 'upload.wikimedia.beta.wmflabs.org' || $serverName === 'upload.wikimedia.beta.wmcloud.org' )
		) {
			// Upload URL hit (to upload.wikimedia.org rather than wiki of origin)...
			return self::initializeForUploadWiki( $pathInfo );
		} elseif ( $serverName === 'auth.wikimedia.org' || $serverName === 'auth.wikimedia.beta.wmflabs.org' || $serverName === 'auth.wikimedia.beta.wmcloud.org' ) {
			// Shared auth domain URL hit.
			// The condition here must match the one in CommonSettings.php where $wmgSharedDomainPathPrefix is set.
			return self::initializeForSharedDomain( $requestUri );
		} else {
			// Regular URL hit (wiki of origin)...
			return self::initializeForWiki( $serverName );
		}
	}

	/**
	 * Initialize object state by mapping an HTTP hostname to a wiki ID.
	 *
	 * @param string $serverName
	 */
	private function setSiteInfoForWiki( $serverName ) {
		$matches = [];

		$staticMappings = [
			// Production
			'api.wikimedia.org' => 'apiportal',
			'test.wikidata.org' => 'testwikidata',
			'test-commons.wikimedia.org' => 'testcommons',
			'www.mediawiki.org' => 'mediawiki',
			'www.wikidata.org' => 'wikidata',
			'wikisource.org' => 'sources',
			'wikitech.wikimedia.org' => 'labs',
			'affcom.wikimedia.org' => 'chapcom',
			'be-tarask.wikipedia.org' => 'be_x_old',
			'ee.wikimedia.org' => 'et',
			'vrt-wiki.wikimedia.org' => 'otrs_wiki',
			'ombuds.wikimedia.org' => 'ombudsmen',
			'www.wikifunctions.org' => 'wikifunctions',
			'wikipedia-pl-sysop.wikimedia.org' => 'sysop_pl',
			'wikipedia-it-arbcom.wikimedia.org' => 'arbcom_it',
			'wikipedia-zh-arbcom.wikimedia.org' => 'arbcom_zh',

			// Beta-only
			// wikidata canonical is www.wikidata in both prod and beta, handled above.
			// This entry is for back-compat with legacy beta.wmflabs.org.
			// TODO: Remove once we have a generic Apache redirect rule (T289318)
			'wikidata.beta.wmflabs.org' => 'wikidata',
		];

		if (
			( strpos( $serverName, 'wmflabs' ) !== false || strpos( $serverName, 'wmcloud' ) !== false )
			&& preg_match( '/^([^.]+)\.([^.]+)\.beta\.(wmflabs|wmcloud)\.org$/', $serverName, $matches )
		) {
			// http://en.wikipedia.beta.wmcloud.org/
			// T289318: or http://en.wikipedia.beta.wmflabs.org/
			$serverName = $matches[1] . '.' . $matches[2] . '.org';
		}

		$lang = null;
		$site = "wikipedia";
		if ( isset( $staticMappings[$serverName] ) ) {
			$lang = $staticMappings[$serverName];
			if ( $serverName === 'ee.wikimedia.org' ) {
				$site = "wikimedia";
			}
		} elseif ( preg_match( '/^(.*)\.([a-z]+)\.org$/', $serverName, $matches ) ) {
			$lang = $matches[1];
			if ( $matches[2] !== 'wikimedia'
				|| ( $matches[2] === 'wikimedia' && in_array(
					$lang,
					$this->wikimediaSubdomains
				) ) ) {
				// wikimedia (non chapters) sites stay as wiki
				$site = $matches[2];
			}
		} else {
			$ip = @$_SERVER['REQUEST_ADDR'];
			$xff = @$_SERVER['HTTP_X_FORWARDED_FOR'];
			$request = @$_SERVER['REQUEST_URI'];
			self::error( "Invalid host name (server: $serverName, request: $request, ip: $ip, xff: $xff).\n", 400 );
		}
		$this->loadDBFromSite( $site, $lang );
	}

	/**
	 * Initialize object state from an upload.wikimedia.org request path.
	 *
	 * @param string $pathInfo
	 */
	private function setSiteInfoForUploadWiki( $pathInfo ) {
		$pathBits = explode( '/', $pathInfo );
		if ( count( $pathBits ) < 3 ) {
			self::error( "Invalid file path info (pathinfo=" . $pathInfo . "), can't determine language.\n" );
		}
		[ , $site, $lang ] = $pathBits;
		$this->loadDBFromSite( $site, $lang );
	}

	/**
	 * Initialize object state from an auth.wikimedia.org request path.
	 *
	 * @param ?string $requestUri
	 * @return void
	 */
	private function setSiteInfoForSharedDomain( $requestUri ) {
		$pathBits = explode( '/', $requestUri, 3 );
		if ( count( $pathBits ) < 3 ) {
			self::error( "Invalid request URI (requestUri=" . $requestUri . "), can't determine language.\n" );
		}
		[ , $dbname, ] = $pathBits;
		// No validation of $dbname at this point - if it's invalid, an error will be produced
		// by getMediaWiki() when it checks isMissing().
		$this->db = $dbname;
	}

	/**
	 * Returns true if the supplied version string has an acceptable format.
	 *
	 * @param string $version
	 * @return bool
	 */
	private function validVersion( $version ) {
		// Examples of expected inputs: 1.43.0-wmf.3, master, next, branch_cut_pretest
		// Rules:
		// * Must begin with alphanum.
		// * Remaining chars can be alphanum, dash or dot
		return preg_match( "/^[0-9a-z][0-9a-z.-]*$/i", $version );
	}

	/**
	 * Initialize object state from CLI `--wiki` parameter.
	 *
	 * This code is based on how MediaWiki's Maintenance.php script reads arguments.
	 */
	private function setSiteInfoForMaintenance() {
		global $argv;

		$dbname = getenv( 'MW_WIKI' ) ?: '';

		# The --wiki param must the second argument to avoid
		# any "options with args" ambiguity (see Maintenance.php).
		if ( isset( $argv[2] ) ) {
			if ( $argv[2] === '--wiki' ) {
				// "script.php --wiki dbname"
				$dbname = $argv[3] ?? '';
			} elseif ( substr( $argv[2], 0, 7 ) === '--wiki=' ) {
				// "script.php --wiki=dbname"
				$dbname = substr( $argv[2], 7 );
			} elseif ( substr( $argv[2], 0, 2 ) !== '--' ) {
				// "script.php dbname"
				$dbname = $argv[2];
				$argv[2] = '--wiki=' . $dbname;
			}
		}

		if ( $dbname === '' ) {
			self::error( "Usage: mwscript scriptName.php --wiki=dbname\n" );
		}

		if ( isset( $argv[3] ) && $argv[3] === '--force-version' ) {
			if ( !isset( $argv[4] ) ) {
				self::error( "--force-version must be followed by a version number\n" );
			}
			$version = $argv[4];
			if ( !self::validVersion( $version ) ) {
				self::error( "Invalid version format passed to --force-version: '$version'\n" );
			}
			$this->version = "php-" . $version;

			# Delete the flag and its parameter so it won't be passed on to the
			# maintenance script.
			unset( $argv[4] );
			unset( $argv[3] );

			# Reindex
			$argv = array_values( $argv );
		}

		$this->db = $dbname;
	}

	/**
	 * This is like setSiteInfoForMaintenance but for old maint scripts based on CommandLineInc.php
	 * instead of Maintenance.php.
	 *
	 * TODO: Remove once all of them have been migrated.
	 */
	private function setSiteInfoForMaintenanceOld() {
		global $argv;
		$dbname = getenv( 'MW_WIKI' ) ?: '';
		# The --wiki param must the second argument to avoid
		# any "options with args" ambiguity (see Maintenance.php).
		if ( isset( $argv[1] ) ) {
			if ( $argv[1] === '--wiki' ) {
				// "script.php --wiki dbname"
				$dbname = $argv[2] ?? '';
			} elseif ( substr( $argv[1], 0, 7 ) === '--wiki=' ) {
				// "script.php --wiki=dbname"
				$dbname = substr( $argv[1], 7 );
			} elseif ( substr( $argv[1], 0, 2 ) !== '--' ) {
				// "script.php dbname"
				$dbname = $argv[1];
				$argv[1] = '--wiki=' . $dbname;
			}
		}
		if ( $dbname === '' ) {
			self::error( "Usage: mwscript scriptName.php --wiki=dbname\n" );
		}
		if ( isset( $argv[2] ) && $argv[2] === '--force-version' ) {
			if ( !isset( $argv[3] ) ) {
				self::error( "--force-version must be followed by a version number" );
			}
			$this->version = "php-" . $argv[3];
			# Delete the flag and its parameter so it won't be passed on to the
			# maintenance script.
			unset( $argv[3] );
			unset( $argv[2] );
			# Reindex
			$argv = array_values( $argv );
		}
		$this->db = $dbname;
	}

	/**
	 * Initialize object state from a legacy site-lang pair.
	 *
	 * @param string $site
	 * @param string $lang
	 */
	private function loadDBFromSite( $site, $lang ) {
		// See also WmfConfig::SUFFIXES
		$dbSuffix = $site === 'wikipedia' ? 'wiki' : $site;
		$this->db = str_replace( "-", "_", $lang . $dbSuffix );
	}

	/**
	 * Get the DB name for this wiki
	 *
	 * @return string
	 */
	public function getDatabase() {
		return $this->db;
	}

	/**
	 * Handle the wfShellWikiCmd hook.
	 *
	 * This converts shell commands like "php $IP/maintenance/foo.php" into
	 * commands that use the "MWScript.php" wrapper, for example:
	 * "php /srv/mediawiki-staging/multiversion/MWScript.php maintenance/foo.php"
	 *
	 * @param string &$script
	 * @param array &$params
	 * @param array &$options
	 * @return bool
	 */
	public static function onWfShellMaintenanceCmd( &$script, array &$params, array &$options ) {
		global $IP;
		if ( strpos( $script, "{$IP}/" ) === 0 ) {
			$script = substr( $script, strlen( "{$IP}/" ) );
		}
		$options['wrapper'] = __DIR__ . '/MWScript.php';
		return true;
	}

	/**
	 * Lazy initialize `$this->version` after the wiki ID has been mapped in `$this->db`.
	 */
	private function loadVersionInfo() {
		global $wmgRealm;

		if ( $this->version !== null ) {
			return;
		}

		// Load the realm-specific wikiversions file,
		// such as wikiversions-labs.php or wikiversions-dev.php
		$phpFilename = $wmgRealm === 'production' ? 'wikiversions.php' : "wikiversions-$wmgRealm.php";
		$phpFilename = dirname( __DIR__ ) . '/' . $phpFilename;

		// This intentionally tolerates absence by using `include` instead of `require`
		$wikiversions = include $phpFilename;
		if ( $wikiversions === false ) {
			self::error( "Unable to open $phpFilename.\n" );
		}
		if ( !is_array( $wikiversions ) ) {
			self::error( "$phpFilename did not return an array as expected.\n" );
		}

		$version = $wikiversions[$this->db] ?? false;

		if ( $version && strpos( $version, 'php-' ) !== 0 ) {
			self::error( "$phpFilename entry must start with `php-` (got `$version`).\n" );
		}

		if ( $version !== false ) {
			// At this point we know there is an entry in wikiversions for the
			// wiki.  If FORCE_MW_VERSION is set in the environment, we want to
			// use that version instead of the one from wikiversions.
			$force_version = getenv( 'FORCE_MW_VERSION' ) ?: '';
			if ( $force_version ) {
				if ( !self::validVersion( $force_version ) ) {
					self::error( "Invalid version format in FORCE_MW_VERSION: '$force_version'\n" );
				}
				$this->version = "php-$force_version";
				return;
			}
		}

		$this->version = $version;
	}

	/**
	 * Whether the mapped wiki ID is not a known wiki in wikiversions.php.
	 *
	 * @return bool
	 */
	public function isMissing() {
		$this->loadVersionInfo();
		return ( $this->version === false );
	}

	/**
	 * Whether the mapped wiki ID is marked as not fully installed. An error
	 * should be shown to web clients, but maintenance scripts should be
	 * allowed, since maintenance scripts are used to do the installation.
	 *
	 * @return bool
	 */
	public function isPreInstall() {
		global $wmgRealm;
		return in_array( 'preinstall', self::getTagsForWiki( $this->db, $wmgRealm ) );
	}

	/**
	 * Get the version directory name for the current wiki ID.
	 *
	 * @return string Version directory name, e.g. "php-X.XX" or "php-master".
	 */
	public function getVersion() {
		$this->loadVersionInfo();
		if ( $this->version === false ) {
			self::error( "no version entry for `{$this->db}`.\n" );
		}
		return $this->version;
	}

	/**
	 * Get the short version name for the current wiki ID
	 *
	 * Do NOT use this to determine paths to MediaWiki directories and such.
	 * Use only for display purposes or in cache keys.
	 *
	 * TODO: Consider deprecating in favour of getVersion() for simplicity,
	 * this is a redundant concept.
	 *
	 * @return string Version number, e.g. "x.xx" or "master".
	 */
	public function getVersionNumber() {
		$this->loadVersionInfo();
		if ( $this->version === false ) {
			self::error( "no version entry for `{$this->db}`.\n" );
		}
		// strip "php-"
		return substr( $this->version, 4 );
	}

	/**
	 * Print error and exit PHP process.
	 *
	 * @param string $msg Error to show to the client
	 * @param int $httpError HTTP header error code
	 * @return void
	 */
	private static function error( $msg, $httpError = 500 ) {
		if ( defined( 'MW_PHPUNIT_TEST' ) ) {
			throw new MWMultiVersionException( $msg );
		}

		$msg = (string)$msg;
		if ( PHP_SAPI !== 'cli' ) {
			$msg = htmlspecialchars( $msg );
			switch ( $httpError ) {
				case 400:
					$httpMsg = 'Bad Request';
					break;
				case 500:
				default:
					$httpMsg = 'Internal server error';
					break;
			}
			header( "HTTP/1.1 $httpError $httpMsg" );
		}
		echo $msg;
		if ( $httpError >= 500 ) {
			trigger_error( $msg, E_USER_ERROR );
		}
		exit( 1 );
	}

	/**
	 * Get the location of the correct version of a MediaWiki web entry point.
	 *
	 * This works based on environmental variables, such as the server name,
	 * as given by CGI (php-fpm).
	 *
	 * This must be called from web requests. For CLI, use getMediaWikiCli.
	 *
	 * If the wiki doesn't exist, then missing.php will
	 * be rendered and flushed to stdout and the process exited.
	 *
	 * If the wiki exists, this function also has these responsibilities:
	 *
	 * - Set the $IP global variable (path to MediaWiki).
	 * - Set the MW_INSTALL_PATH environmental variable.
	 * - Change PHP's current directory to the chosen MediaWiki install path.
	 *
	 * @param string $file File path (relative to MediaWiki dir)
	 * @param string|null $wiki Force the Wiki ID rather than detecting it
	 * @return string Absolute file path with proper MW location
	 */
	public static function getMediaWiki( $file, $wiki = null ) {
		global $IP;

		if ( $wiki === null ) {
			$scriptName = @$_SERVER['SCRIPT_NAME'];
			$serverName = @$_SERVER['SERVER_NAME'];
			$pathInfo = @$_SERVER['PATH_INFO'];
			$requestUri = @$_SERVER['REQUEST_URI'];
			$multiVersion = self::initializeFromServerData( $serverName, $scriptName, $pathInfo, $requestUri );
		} else {
			$multiVersion = self::initializeFromDBName( $wiki );
		}

		// Wiki doesn't exist, yet?
		if ( $multiVersion->isMissing() || $multiVersion->isPreInstall() ) {
			// same hack as CommonSettings.php
			header( 'Cache-control: no-cache' );
			include __DIR__ . '/missing.php';
			exit;
		}

		// Get the MediaWiki version running on this wiki...
		$version = $multiVersion->getVersion();

		// Get the correct MediaWiki path based on this version...
		$IP = MEDIAWIKI_DEPLOYMENT_DIR . "/$version";

		chdir( $IP );
		putenv( "MW_INSTALL_PATH=$IP" );

		return "$IP/$file";
	}

	/**
	 * Get the location of the correct version of a MediaWiki CLI
	 * entry-point file given the `--wiki` parameter passed in.
	 *
	 * This also has some other effects:
	 * (a) Sets the $IP global variable (path to MediaWiki)
	 * (b) Sets the MW_INSTALL_PATH environmental variable
	 * (c) Changes PHP's current directory to the directory of this file.
	 *
	 * @param string $file File path (relative to MediaWiki dir or absolute)
	 * @param bool $useOld Whether the cli file is using CommandLineInc
	 * @return string Absolute file path with proper MW location
	 */
	public static function getMediaWikiCli( $file, $useOld = false ) {
		global $argv, $IP;

		$multiVersion = self::getInstance();
		if ( !$multiVersion ) {
			if ( $useOld ) {
				$multiVersion = self::initializeForMaintenanceOld();
			} else {
				$multiVersion = self::initializeForMaintenance();
			}
		}
		if ( $multiVersion->getDatabase() === 'testwiki' ) {
			define( 'TESTWIKI', 1 );
		}

		# Get the MediaWiki version running on this wiki...
		$version = $multiVersion->getVersion();

		# Get the correct MediaWiki path based on this version...
		$IP = dirname( __DIR__ ) . "/$version";
		// Make the script file path absolute.
		// Can't be done sooner as the version thus the actual $IP was not determined.
		$scriptIndex = $useOld ? 0 : 1;
		$scriptPath = $argv[$scriptIndex];
		if ( $scriptPath !== '' && $scriptPath[0] !== '/' && strpos( $scriptPath, '/' ) !== false ) {
			$argv[$scriptIndex] = "$IP/$scriptPath";
		}

		putenv( "MW_INSTALL_PATH=$IP" );

		if ( $file !== '' && $file[0] === '/' ) {
			return $file;
		} else {
			return "$IP/$file";
		}
	}

	/**
	 * Get a list of dblist names that contain a given wiki.
	 *
	 * @param string $dbName
	 * @param string $realm
	 * @return string[]
	 */
	public static function getTagsForWiki( string $dbName, string $realm = 'production' ): array {
		return WmfConfig::getTagsForWiki( $dbName, $realm );
	}
}
